<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tudo Voice Uploader</title>
  <style>
    body { background: #111; color: #eee; font-family: sans-serif; text-align: center; padding: 20px; }
    #meter { width: 300px; height: 30px; background-color: #333; border-radius: 5px; overflow: hidden; margin: 20px auto; }
    #meter-fill { height: 100%; width: 0%; background-color: #4caf50; transition: width 0.1s; }
    button { margin: 10px; padding: 10px 20px; font-size: 16px; }
    #status { margin-top: 20px; font-size: 18px; }
    .uploading { animation: blink 1s infinite; }
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
  </style>
</head>

<body>
  <h1>Tudo Voice Uploader</h1>

  <form id="uploadForm">
    <button type="button" id="recordButton">Record</button>
    <button type="button" id="stopButton" disabled>Stop</button><br><br>
  </form>

  <div id="meter">
    <div id="meter-fill"></div>
  </div>

  <p id="status"></p>

<script>
window.onload = function() {
  let mediaRecorder;
  let audioChunks;
  let audioContext;
  let analyser;
  let microphone;
  let meterFill;
  let animationId;

  meterFill = document.getElementById('meter-fill');
  const recordButton = document.getElementById('recordButton');
  const stopButton = document.getElementById('stopButton');
  const status = document.getElementById('status');

  recordButton.addEventListener('click', async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    microphone = audioContext.createMediaStreamSource(stream);
    microphone.connect(analyser);
    analyser.fftSize = 256;

    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    audioChunks = [];

    mediaRecorder.ondataavailable = event => {
      audioChunks.push(event.data);
    };

    mediaRecorder.onstop = async () => {
      stopButton.disabled = true;
      recordButton.disabled = false;
      cancelAnimationFrame(animationId);
      audioContext.close();
      status.textContent = "Uploading...";
      status.classList.add('uploading');

      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      await uploadBlobToServer(audioBlob);
    };

    mediaRecorder.start();
    recordButton.disabled = true;
    stopButton.disabled = false;
    status.textContent = "Recording...";

    animateMeter();

    setTimeout(() => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    }, 30000); // Auto stop at 30 seconds
  });

  stopButton.addEventListener('click', () => {
    if (mediaRecorder && mediaRecorder.state === "recording") {
      mediaRecorder.stop();
    }
  });

  function animateMeter() {
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    const draw = () => {
      analyser.getByteFrequencyData(dataArray);
      let volume = dataArray.reduce((a, b) => a + b) / dataArray.length;
      let percent = Math.min(100, (volume / 255) * 100);
      meterFill.style.width = percent + "%";
      animationId = requestAnimationFrame(draw);
    };
    draw();
  }

  async function uploadBlobToServer(blob) {
    try {
      const formData = new FormData();
      formData.append('file', blob, `voice_note_${Date.now()}.webm`);

      const uploadResponse = await fetch('/upload', {
        method: 'POST',
        body: formData
      });

      if (uploadResponse.ok) {
        status.textContent = '✅ Upload complete!';
        status.classList.remove('uploading');
        console.log('✅ File uploaded successfully!');
      } else {
        status.textContent = '❌ Upload failed.';
        status.classList.remove('uploading');
        console.error('❌ Upload failed with status:', uploadResponse.status);
      }
    } catch (error) {
      console.error(error);
      status.textContent = '❌ Upload failed.';
      status.classList.remove('uploading');
    }
  }
}
</script>
</body>
</html>
